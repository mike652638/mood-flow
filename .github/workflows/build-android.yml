name: Build Android APK

on:
  workflow_dispatch:
    inputs:
      smoke_test:
        description: 'Run smoke test (requires connected device & Windows runner)'
        type: boolean
        default: false
      prefer_emulator:
        description: 'Prefer emulator when selecting device'
        type: boolean
        default: false
      update_url:
        description: 'Override remote updates.json URL (e.g., https://example.com/releases/updates.json)'
        type: string
        required: false
      version_name:
        description: 'Override Android versionName (semantic version, e.g., 1.2.3)'
        type: string
        required: false
      version_code:
        description: 'Override Android versionCode (integer)'
        type: string
        required: false
      mandatory:
        description: 'Force update (write mandatory=true to updates.json)'
        type: boolean
        default: false
      release_notes_path:
        description: 'Optional path to release notes markdown for summarization'
        type: string
        required: false
  # 优化：仅在版本标签触发（避免同时因分支推送与标签推送触发两次）
  push:
    tags: ['v*', 'v*-ci*']
  pull_request:
    branches: [main, master]

permissions:
  contents: write

# 并发策略：同一标签仅保留最新运行，取消进行中的重复运行
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  build-android:
    # 允许标签或手动触发运行；避免因分支 push 引发重复构建
    if: startsWith(github.ref, 'refs/tags/') || github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    env:
      # build-android.cmd will respect SKIP_SMOKE_TEST/PREFER_EMULATOR when used by CI
      SKIP_SMOKE_TEST: ${{ ! inputs.smoke_test }}
      PREFER_EMULATOR: ${{ inputs.prefer_emulator }}
      # Cloudflare R2 configuration (set via repo/org secrets)
      R2_ACCOUNT_ID: ${{ secrets.R2_ACCOUNT_ID }}
      R2_ACCESS_KEY_ID: ${{ secrets.R2_ACCESS_KEY_ID }}
      R2_SECRET_ACCESS_KEY: ${{ secrets.R2_SECRET_ACCESS_KEY }}
      R2_BUCKET: ${{ secrets.R2_BUCKET }}
      R2_PUBLIC_BASE: ${{ secrets.R2_PUBLIC_BASE }}
      # Android signing secrets exposed as env for step conditions
      ANDROID_KEYSTORE_BASE64: ${{ secrets.ANDROID_KEYSTORE_BASE64 }}
      ANDROID_KEYSTORE_PASSWORD: ${{ secrets.ANDROID_KEYSTORE_PASSWORD }}
      ANDROID_KEY_ALIAS: ${{ secrets.ANDROID_KEY_ALIAS }}
      ANDROID_KEY_PASSWORD: ${{ secrets.ANDROID_KEY_PASSWORD }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Setup Java
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: '17'

      - name: Setup Android SDK
        uses: android-actions/setup-android@v3

      - name: Set update URL env (R2 base)
        shell: bash
        run: |
          set -e
          # Prefer manual override if provided
          CUSTOM="${{ inputs.update_url }}"
          if [ -n "$CUSTOM" ]; then
            UPD="$CUSTOM"
          elif [ -n "${R2_PUBLIC_BASE}" ]; then
            UPD="${R2_PUBLIC_BASE}/releases/updates.json"
          elif [ -n "${R2_BUCKET}" ]; then
            UPD="https://${R2_BUCKET}.r2.dev/releases/updates.json"
          else
            # Fallback to local path; app 端将有多源兜底逻辑
            UPD="/updates.json"
          fi
          echo "VITE_APP_UPDATE_URL=${UPD}" >> "$GITHUB_ENV"
          echo "Resolved update URL: ${UPD}"

      - name: Install dependencies
        run: npm ci

      - name: Lint (strict)
        run: npm run lint -- --max-warnings=0

      - name: Sync Android versionName/versionCode (tag/env/inputs override)
        if: ${{ startsWith(github.ref, 'refs/tags/') || github.event_name == 'workflow_dispatch' }}
        shell: bash
        run: |
          set -e
          FILE="android/app/build.gradle"
          if [ ! -f "$FILE" ]; then
            echo "build.gradle not found at $FILE; skip"
            exit 0
          fi

          TAG="${GITHUB_REF_NAME}"
          # Resolve overrides from workflow_dispatch inputs first, then env variables
          OVERRIDE_NAME_INPUT="${{ inputs.version_name }}"
          OVERRIDE_CODE_INPUT="${{ inputs.version_code }}"
          OVERRIDE_NAME_ENV="${VERSION_NAME_OVERRIDE:-}"
          OVERRIDE_CODE_ENV="${VERSION_CODE_OVERRIDE:-}"
          OVERRIDE_NAME="$OVERRIDE_NAME_INPUT"
          if [ -z "$OVERRIDE_NAME" ]; then OVERRIDE_NAME="$OVERRIDE_NAME_ENV"; fi
          OVERRIDE_CODE="$OVERRIDE_CODE_INPUT"
          if [ -z "$OVERRIDE_CODE" ]; then OVERRIDE_CODE="$OVERRIDE_CODE_ENV"; fi

          # Determine base semantic version (drop any -ci suffix) or use override
          if [ -n "$OVERRIDE_NAME" ]; then
            BASE_VERSION="$OVERRIDE_NAME"
          else
            BASE_VERSION=$(echo "$TAG" | sed -E 's/^v([0-9]+\.[0-9]+\.[0-9]+).*/\1/')
          fi

          CURRENT_NAME=$(grep -m1 -E 'versionName\s+"[^"]+"' "$FILE" | sed -E 's/.*"([^"]+)".*/\1/' || true)
          CURRENT_CODE=$(grep -m1 -E 'versionCode\s+[0-9]+' "$FILE" | sed -E 's/.*versionCode\s+([0-9]+).*/\1/' || echo 1)

          # Compute new versionName
          NEW_NAME="$CURRENT_NAME"
          if [ -n "$BASE_VERSION" ] && echo "$BASE_VERSION" | grep -Eq '^[0-9]+\.[0-9]+\.[0-9]+$'; then
            NEW_NAME="$BASE_VERSION"
          fi

          # Compute new versionCode (override > run_number > bump)
          if [ -n "$OVERRIDE_CODE" ] && echo "$OVERRIDE_CODE" | grep -Eq '^[0-9]+$'; then
            NEW_CODE="$OVERRIDE_CODE"
          else
            RUN="${GITHUB_RUN_NUMBER}"
            CAND="${RUN:-0}"
            if [ "$CAND" -le "$CURRENT_CODE" ]; then
              NEW_CODE=$((CURRENT_CODE + 1))
            else
              NEW_CODE="$CAND"
            fi
          fi

          # Apply changes
          sed -i -E "s/versionName\s+\"[^\"]+\"/versionName \"${NEW_NAME}\"/" "$FILE"
          if grep -q -E 'versionCode\s+[0-9]+' "$FILE"; then
            sed -i -E "s/versionCode\s+[0-9]+/versionCode ${NEW_CODE}/" "$FILE"
          else
            # Insert versionCode if missing, next line after versionName
            awk -v code="$NEW_CODE" '
              /versionName\s+\"/ && !vc { print; print "        versionCode " code; vc=1; next }
              { print }
            ' "$FILE" > "$FILE.tmp" && mv "$FILE.tmp" "$FILE"
          fi

          echo "Synced versionName: ${CURRENT_NAME} -> ${NEW_NAME}"
          echo "Synced versionCode: ${CURRENT_CODE} -> ${NEW_CODE}"
          echo "VERSION_NAME=${NEW_NAME}" >> "$GITHUB_ENV"
          echo "VERSION_CODE=${NEW_CODE}" >> "$GITHUB_ENV"

      - name: Build web app
        run: npm run build
        env:
          VITE_SUPABASE_URL: ${{ secrets.VITE_SUPABASE_URL }}
          VITE_SUPABASE_ANON_KEY: ${{ secrets.VITE_SUPABASE_ANON_KEY }}
          VITE_APP_UPDATE_URL: ${{ env.VITE_APP_UPDATE_URL }}
          VITE_APP_VERSION: ${{ env.VERSION_NAME }}

      - name: Sync Capacitor
        run: npx cap sync android

      - name: Validate App IDs consistency (applicationId vs capacitor appId)
        shell: bash
        run: |
          set -e
          APPID=$(grep -m1 -E 'applicationId\s+"[^"]+"' android/app/build.gradle | sed -E 's/.*"([^"]+)".*/\1/')
          CAPID=$(grep -m1 -E "appId:\s*'[^']+'" capacitor.config.ts | sed -E "s/.*'([^']+)'.*/\1/")
          if [ -n "$APPID" ] && [ -n "$CAPID" ] && [ "$APPID" != "$CAPID" ]; then
            echo "Config mismatch: build.gradle applicationId=$APPID, capacitor.config.ts appId=$CAPID" >&2
            exit 1
          fi
          echo "Config IDs validated: $APPID"
      - name: Build Android APK (Debug)
        run: |
          cd android
          chmod +x ./gradlew
          ./gradlew assembleDebug --no-daemon --stacktrace || { echo "Gradle Debug failed; showing outputs"; ls -R app/build/outputs || true; ls -R app/build/reports || true; exit 1; }

      - name: Prepare signing keys (Release)
        if: ${{ env.ANDROID_KEYSTORE_BASE64 != '' }}
        run: |
          mkdir -p android/app/keystore
          echo "${{ secrets.ANDROID_KEYSTORE_BASE64 }}" | base64 -d > android/app/keystore/release.keystore
          cat > android/app/keystore/keystore.properties << 'EOF'
          storeFile=keystore/release.keystore
          storePassword=${{ secrets.ANDROID_KEYSTORE_PASSWORD }}
          keyAlias=${{ secrets.ANDROID_KEY_ALIAS }}
          keyPassword=${{ secrets.ANDROID_KEY_PASSWORD }}
          EOF

      - name: Validate Release Keystore & Alias
        if: ${{ env.ANDROID_KEYSTORE_BASE64 != '' }}
        shell: bash
        run: |
          set -e
          test -f android/app/keystore/release.keystore || { echo "release.keystore missing" >&2; exit 1; }
          test -f android/app/keystore/keystore.properties || { echo "keystore.properties missing" >&2; exit 1; }
          EXPECT_ALIAS="${{ secrets.ANDROID_KEY_ALIAS }}"
          echo "Expect alias: ${EXPECT_ALIAS}"
          ACTUAL_ALIAS=$(keytool -list -v -keystore android/app/keystore/release.keystore -storepass "${{ secrets.ANDROID_KEYSTORE_PASSWORD }}" | grep -m1 '^Alias name:' | sed 's/.*: //') || true
          echo "Actual alias: ${ACTUAL_ALIAS}"
          keytool -list -keystore android/app/keystore/release.keystore -storepass "${{ secrets.ANDROID_KEYSTORE_PASSWORD }}" -alias "${EXPECT_ALIAS}" >/dev/null || { echo "Alias not found or mismatch" >&2; exit 1; }
          # Verify key password is valid for the alias by attempting to export the certificate
          keytool -exportcert -alias "${EXPECT_ALIAS}" -keystore android/app/keystore/release.keystore -storepass "${{ secrets.ANDROID_KEYSTORE_PASSWORD }}" -keypass "${{ secrets.ANDROID_KEY_PASSWORD }}" -rfc >/dev/null || { echo "Key password invalid for alias ${EXPECT_ALIAS}" >&2; exit 1; }

      - name: Build Android Release (APK + AAB)
        if: ${{ env.ANDROID_KEYSTORE_BASE64 != '' }}
        run: |
          cd android
          chmod +x ./gradlew
          ./gradlew assembleRelease bundleRelease --no-daemon --stacktrace || { echo "Gradle Release failed; showing outputs"; ls -R app/build/outputs || true; ls -R app/build/reports || true; exit 1; }
          ls -lh app/build/outputs/apk/release/app-release.apk || true
          ls -lh app/build/outputs/bundle/release/app-release.aab || true

      # Normalize mandatory input for updates.json (string true/false)
      - name: Normalize mandatory flag
        shell: bash
        run: |
          set -e
          M_IN="${{ inputs.mandatory }}"
          case "$M_IN" in
            true|True|TRUE|1|yes|Yes|YES) MANDATORY_STR="true" ;;
            false|False|FALSE|0|no|No|NO|"") MANDATORY_STR="false" ;;
            *) MANDATORY_STR="false" ;;
          esac
          echo "MANDATORY_STR=${MANDATORY_STR}" >> "$GITHUB_ENV"

      - name: Publish Debug APK to R2 (sinternal) without updating updates.json
        if: ${{ env.ANDROID_KEYSTORE_BASE64 == '' }}
        shell: bash
        env:
          R2_ACCOUNT_ID: ${{ env.R2_ACCOUNT_ID }}
          R2_BUCKET: ${{ env.R2_BUCKET }}
          R2_PUBLIC_BASE: ${{ env.R2_PUBLIC_BASE }}
          R2_ACCESS_KEY_ID: ${{ env.R2_ACCESS_KEY_ID }}
          R2_SECRET_ACCESS_KEY: ${{ env.R2_SECRET_ACCESS_KEY }}
          VERSION_NAME: ${{ env.VERSION_NAME }}
        run: |
          set -e
          # Configure AWS credentials for R2
          export AWS_ACCESS_KEY_ID="$R2_ACCESS_KEY_ID"
          export AWS_SECRET_ACCESS_KEY="$R2_SECRET_ACCESS_KEY"
          export AWS_DEFAULT_REGION="us-east-1"
          APK_PATH="android/app/build/outputs/apk/debug/app-debug.apk"
          test -f "$APK_PATH" || { echo "Debug APK not found at $APK_PATH" >&2; exit 1; }
          SHORT_SHA=$(git rev-parse --short HEAD)
          STAMP=$(date -u +%Y%m%d%H%M)
          RUN="$GITHUB_RUN_NUMBER"
          VER="${VERSION_NAME:-0.0.0}"
          NAME="mood-flow-${VER}-sinternal-${STAMP}-r${RUN}-${SHORT_SHA}.apk"
          mkdir -p dist/internal
          cp "$APK_PATH" "dist/internal/$NAME"
          ENDPOINT="https://${R2_ACCOUNT_ID}.r2.cloudflarestorage.com"
          # Upload debug APK to internal channel; do NOT update updates.json
          aws s3 cp "dist/internal/$NAME" "s3://${R2_BUCKET}/internal/$NAME" --endpoint-url "$ENDPOINT" --no-progress
          echo "Uploaded Debug APK to R2 internal channel (sinternal)"

      # Optional: Use unified script (Windows runner required for device install/smoke test)
      # - name: Build via unified script (optional)
      #   if: ${{ false }}
      #   run: |
      #     cmd /c .\build-android.cmd release -NoInstall ${ inputs.smoke_test && '' || '-SkipSmokeTest' }
      #   shell: bash

      - name: Tag artifacts (release/signed/internal/store)
        shell: bash
        run: |
          set -e
          CMD=(node scripts/tag-artifacts.cjs --labels "release,signed,sinternal,store" --product mood-flow)
          if [ -n "$VERSION_NAME" ]; then
            CMD+=(--version "$VERSION_NAME")
          fi
          echo "Running: ${CMD[*]}"
          "${CMD[@]}"

      - name: Generate checksums for tagged artifacts (APK/AAB)
        if: ${{ env.ANDROID_KEYSTORE_BASE64 != '' }}
        shell: bash
        run: |
          set -e
          while IFS= read -r -d '' f; do
            echo "Checksumming $f"
            sha256sum "$f" | tee "${f}.sha256"
            sha1sum   "$f" | tee "${f}.sha1"
            md5sum    "$f" | tee "${f}.md5"
          done < <(find android/app/build/outputs -type f \( -name "mood-flow-*.apk" -o -name "mood-flow-*.aab" \) -print0)

      - name: Read Android versionName from Gradle
        shell: bash
        run: |
          set -e
          VERSION_NAME=$(grep -m1 -E 'versionName\s+"[^"]+"' android/app/build.gradle | sed -E 's/.*"([^"]+)".*/\1/')
          if [ -z "$VERSION_NAME" ]; then
            echo "versionName not found in build.gradle" >&2
          else
            echo "Found versionName: $VERSION_NAME"
          fi
          echo "VERSION_NAME=$VERSION_NAME" >> "$GITHUB_ENV"

      - name: Summarize release notes for updates.json
        if: ${{ env.ANDROID_KEYSTORE_BASE64 != '' }}
        shell: bash
        run: |
          set -e
          # Prefer explicit input path; fallback to dist/meta/release-notes.md
          INPUT_PATH="${{ inputs.release_notes_path }}"
          if [ -z "$INPUT_PATH" ]; then INPUT_PATH="dist/meta/release-notes.md"; fi
          if [ -f "$INPUT_PATH" ]; then
            node scripts/summarize-release-notes.cjs "$INPUT_PATH" > .notes.txt || true
            NOTES_SUMMARY=$(sed -e ':a;N;$!ba;s/\n/ /g' .notes.txt)
            if [ -z "$NOTES_SUMMARY" ]; then
              NOTES_SUMMARY="Release ${VERSION_NAME} generated by CI. See GitHub Release for details."
            fi
            echo "NOTES_SUMMARY=$NOTES_SUMMARY" >> "$GITHUB_ENV"
            echo "Notes summary: $NOTES_SUMMARY"
          else
            NOTES_SUMMARY="Release ${VERSION_NAME} generated by CI. See GitHub Release for details."
            echo "NOTES_SUMMARY=$NOTES_SUMMARY" >> "$GITHUB_ENV"
            echo "Notes summary (default): $NOTES_SUMMARY"
          fi

      - name: Append update policy to release notes (mandatory/notes)
        if: ${{ env.ANDROID_KEYSTORE_BASE64 != '' }}
        shell: bash
        run: |
          set -e
          BODY="dist/meta/release-notes.md"
          # If release notes body is missing, create a default one to avoid failing the workflow
          if [ ! -f "$BODY" ]; then
            mkdir -p "$(dirname "$BODY")"
            {
              echo "# Release ${VERSION_NAME}"
              echo
              if [ -n "$NOTES_SUMMARY" ]; then
                echo "${NOTES_SUMMARY}"
              else
                echo "Release ${VERSION_NAME} generated by CI. See GitHub Release for details."
              fi
            } > "$BODY"
            echo "Created default release notes at $BODY"
          fi
          {
            echo
            echo "## Update Policy"
            echo "- Mandatory: ${MANDATORY_STR:-false}"
            if [ -n "$NOTES_SUMMARY" ]; then
              echo "- Notes: ${NOTES_SUMMARY}"
            else
              echo "- Notes: Release ${VERSION_NAME} generated by CI. See GitHub Release for details."
            fi
          } >> "$BODY"

      - name: Upload Release APK to Cloudflare R2 (store label)
        if: ${{ env.ANDROID_KEYSTORE_BASE64 != '' && env.R2_ACCOUNT_ID != '' && env.R2_ACCESS_KEY_ID != '' && env.R2_SECRET_ACCESS_KEY != '' && env.R2_BUCKET != '' }}
        shell: bash
        run: |
          set -e
          echo "Installing AWS CLI (for S3-compatible R2)"
          pip3 install --user awscli
          export PATH="$HOME/.local/bin:$PATH"
          echo "Configuring AWS CLI credentials"
          aws configure set aws_access_key_id "$R2_ACCESS_KEY_ID"
          aws configure set aws_secret_access_key "$R2_SECRET_ACCESS_KEY"
          aws configure set default.region us-east-1
          echo "Selecting APK file (store label)"
          APK_FILE=$(ls -1 android/app/build/outputs/apk/release/mood-flow-*-store-*.apk | tail -n1)
          if [ -z "$APK_FILE" ]; then
            echo "No store-labeled APK found. Fallback to release-labeled."
            APK_FILE=$(ls -1 android/app/build/outputs/apk/release/mood-flow-*-release-*.apk | tail -n1)
          fi
          if [ -z "$APK_FILE" ]; then
            echo "No APK to upload; skipping R2 upload (non-fatal)"
            exit 0
          fi
          BASENAME=$(basename "$APK_FILE")
          echo "Uploading $BASENAME to R2 bucket $R2_BUCKET"
          aws --endpoint-url "https://${R2_ACCOUNT_ID}.r2.cloudflarestorage.com" \
            s3 cp "$APK_FILE" "s3://${R2_BUCKET}/releases/${BASENAME}" \
            --content-type application/vnd.android.package-archive \
            --acl public-read || true
          # Compose public URL if base provided; otherwise use r2.dev convention
          if [ -n "$R2_PUBLIC_BASE" ]; then
            R2_URL="${R2_PUBLIC_BASE}/releases/${BASENAME}"
          else
            R2_URL="https://${R2_BUCKET}.r2.dev/releases/${BASENAME}"
          fi
          echo "R2_URL=${R2_URL}" >> "$GITHUB_ENV"
          # Also print the public URL to logs so external monitors can parse it
          echo "Resolved R2 APK public URL: ${R2_URL}"
          echo "::notice title=R2 APK URL::${R2_URL}"

      - name: Update public/updates.json with APK URL
        if: ${{ env.R2_URL != '' }}
        shell: bash
        run: |
          set -e
          CMD=(node scripts/update-updates-json.cjs --apk-url "$R2_URL")
          if [ -n "$VERSION_NAME" ]; then CMD+=(--version "$VERSION_NAME"); fi
          if [ -n "$NOTES_SUMMARY" ]; then CMD+=(--notes "$NOTES_SUMMARY"); fi
          if [ -n "$MANDATORY_STR" ]; then CMD+=(--mandatory "$MANDATORY_STR"); fi
          echo "Running: ${CMD[*]}"
          "${CMD[@]}"

      - name: Validate updates.json structure (jq)
        if: ${{ env.R2_URL != '' }}
        shell: bash
        run: |
          set -e
          echo "Validating public/updates.json"
          sudo apt-get update -y >/dev/null 2>&1 || true
          sudo apt-get install -y jq >/dev/null 2>&1 || true
          jq -e 'type=="object" and has("latestVersion") and (.latestVersion|type=="string" and test("^[0-9]+\\.[0-9]+\\.[0-9]+$")) and has("androidApkUrl") and (.androidApkUrl|type=="string" and length>0) and has("publishedAt") and (.publishedAt|type=="string") and has("mandatory") and (.mandatory|type=="boolean")' public/updates.json >/dev/null
          echo "updates.json is valid and contains required fields"
      - name: Validate updates.json structure (Node)
        if: ${{ env.R2_URL != '' }}
        shell: bash
        run: |
          set -e
          echo "Node parsing public/updates.json"
          node -e 'const fs=require("fs");const p="public/updates.json";let s=fs.readFileSync(p,"utf8").replace(/^\uFEFF/,"");let j=JSON.parse(s);const has=k=>Object.prototype.hasOwnProperty.call(j,k);if(!has("latestVersion")||typeof j.latestVersion!=="string")throw new Error("latestVersion invalid");if(!has("androidApkUrl")||typeof j.androidApkUrl!=="string"||!j.androidApkUrl.length)throw new Error("androidApkUrl invalid");if(!has("publishedAt")||typeof j.publishedAt!=="string")throw new Error("publishedAt invalid");if(!has("mandatory")||typeof j.mandatory!=="boolean")throw new Error("mandatory invalid");if(has("releaseNotes")&&typeof j.releaseNotes!=="string")throw new Error("releaseNotes invalid type");process.stdout.write("Node JSON parse ok\\n");'

      - name: Upload updates.json to Cloudflare R2
        if: ${{ env.R2_ACCOUNT_ID != '' && env.R2_ACCESS_KEY_ID != '' && env.R2_SECRET_ACCESS_KEY != '' && env.R2_BUCKET != '' }}
        shell: bash
        run: |
          set -e
          echo "Installing AWS CLI (for S3-compatible R2)"
          pip3 install --user awscli
          export PATH="$HOME/.local/bin:$PATH"
          echo "Configuring AWS CLI credentials"
          aws configure set aws_access_key_id "$R2_ACCESS_KEY_ID"
          aws configure set aws_secret_access_key "$R2_SECRET_ACCESS_KEY"
          aws configure set default.region us-east-1
          echo "Uploading updates.json to R2"
          SRC="public/updates.json"
          DEST="s3://${R2_BUCKET}/releases/updates.json"
          aws --endpoint-url "https://${R2_ACCOUNT_ID}.r2.cloudflarestorage.com" s3 cp "$SRC" "$DEST" --content-type application/json --acl public-read || true

      - name: Commit updates.json back to repo (branch runs only)
        if: ${{ env.R2_URL != '' && github.event_name != 'pull_request' && startsWith(github.ref, 'refs/heads/') }}
        shell: bash
        run: |
          set -e
          # Extra safety: skip when on detached HEAD (e.g., tag runs)
          if [ "$(git rev-parse --abbrev-ref HEAD)" = "HEAD" ]; then
            echo "Detached HEAD detected (tag run); skip committing updates.json"
            exit 0
          fi
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add public/updates.json
          if git diff --cached --quiet; then
            echo "No updates to commit"
          else
            git commit -m "chore(ci): update updates.json with R2 APK URL"
            git push
          fi

      - name: Generate SBOM (npm)
        shell: bash
        run: |
          set -e
          mkdir -p dist/meta
          # Generate CycloneDX SBOM for npm deps. The current CLI no longer supports --include-dev;
          # dev dependencies are included by default unless NODE_ENV=production.
          npx --yes @cyclonedx/cyclonedx-npm --output-file dist/meta/sbom-npm.json

      - name: Generate signing metadata (keystore fingerprints)
        if: ${{ env.ANDROID_KEYSTORE_BASE64 != '' }}
        continue-on-error: true
        shell: bash
        run: |
          set -e
          mkdir -p dist/meta
          # Force predictable English output to match parsing patterns
          # Note: omit -keypass to avoid listing failures on some JDK/keytool versions
          if LC_ALL=C keytool -list -v -keystore android/app/keystore/release.keystore -storepass "${{ secrets.ANDROID_KEYSTORE_PASSWORD }}" -alias "${{ secrets.ANDROID_KEY_ALIAS }}" > dist/meta/signing.txt; then
            # Use sed/head pipelines that do not fail under set -e -o pipefail
            alias=$(sed -n 's/^Alias name: //p' dist/meta/signing.txt | head -n1)
            sha256=$(sed -n 's/^SHA-256: //p' dist/meta/signing.txt | head -n1)
            sha1=$(sed -n 's/^SHA1: //p' dist/meta/signing.txt | head -n1)
            md5=$(sed -n 's/^MD5: //p' dist/meta/signing.txt | head -n1)
            printf '{\n  "alias": "%s",\n  "sha256": "%s",\n  "sha1": "%s",\n  "md5": "%s",\n  "generatedAt": "%s"\n}\n' "$alias" "$sha256" "$sha1" "$md5" "$(date -Iseconds)" > dist/meta/signing-metadata.json
          else
            echo "keytool listing failed; writing minimal signing-metadata.json and continuing."
            printf '{\n  "alias": "",\n  "sha256": "",\n  "sha1": "",\n  "md5": "",\n  "error": "keytool failed",\n  "generatedAt": "%s"\n}\n' "$(date -Iseconds)" > dist/meta/signing-metadata.json
          fi

      - name: Generate artifacts manifest and release notes
        shell: bash
        run: |
          set -e
          mkdir -p dist/meta
          node <<'EOF'
          const fs=require('fs'); const path=require('path'); const cp=require('child_process');
          const base='android/app/build/outputs';
          const files=[];
          function collect(dir) {
            if (!fs.existsSync(dir)) return;
            for (const f of fs.readdirSync(dir)) {
              const full=path.join(dir,f);
              const stat=fs.statSync(full);
              if (stat.isDirectory()) collect(full);
              else if (/(\.apk|\.aab)$/.test(f) && /^mood-flow-/.test(f)) files.push(full);
            }
          }
          collect(path.join(base,'apk'));
          collect(path.join(base,'bundle'));
          const items = files.map(f => {
            const rel = path.relative(process.cwd(), f);
            const size = fs.statSync(f).size;
            const ext = path.extname(f).slice(1);
            const bn = path.basename(f);
            const m = bn.match(/^mood-flow-([^-]+)-([^-]+)-([^-]+)(?:-([^-]+))?/);
            const version = m ? m[1] : '';
            const label = m ? m[2] : '';
            const date = m ? m[3] : '';
            const sha256 = readHash(f + '.sha256');
            const sha1 = readHash(f + '.sha1');
            const md5 = readHash(f + '.md5');
            return { file: rel, ext, size, version, label, date, sha256, sha1, md5 };
            function readHash(p) {
              try {
                const t = fs.readFileSync(p,'utf8').trim();
                const first = t.split(/\s+/)[0];
                return first;
              } catch(e) { return ''; }
            }
          });
          const runNumber = process.env.GITHUB_RUN_NUMBER || '';
          const shaShort = (process.env.GITHUB_SHA || '').slice(0,7);
          let signing = {};
          try { signing = JSON.parse(fs.readFileSync('dist/meta/signing-metadata.json','utf8')); } catch(e) {}
          // generator version is bound to tag-artifacts.cjs version in package.json (if present)
          let generatorVersion = '1.0.0';
          try {
            const pkg = JSON.parse(fs.readFileSync('package.json','utf8'));
            if (pkg && pkg.version) generatorVersion = pkg.version;
          } catch(e) {}
          const manifest = {
            generatedAt: new Date().toISOString(),
            product: 'mood-flow',
            ci: { runNumber },
            git: { shaShort },
            generator: { name: 'android-ci-meta-generator', version: generatorVersion },
            signing,
            items
          };
          fs.writeFileSync('dist/meta/artifacts-manifest.json', JSON.stringify(manifest, null, 2));
          // Release notes include manifest key info
          const tag = process.env.GITHUB_REF_NAME || '';
          let prev = '';
          try { prev = cp.execSync('git describe --tags --abbrev=0 HEAD^', {stdio:['ignore','pipe','ignore']}).toString().trim(); } catch(e) {}
          let log = '';
          try {
            const range = prev ? `${prev}..HEAD` : '';
            log = cp.execSync(`git log --pretty=format:"- %s (%h) by %an" ${range}`, {stdio:['ignore','pipe','ignore']}).toString();
          } catch(e) {}
          const byLabel = items.reduce((acc, it) => { (acc[it.label] ||= []).push(it); return acc; }, {});
          let notes = `# Release ${tag}\n\n## Build Metadata\n- Product: ${manifest.product}\n- CI Run: ${runNumber}\n- SHA: ${shaShort}\n- Generator: ${manifest.generator.name} v${manifest.generator.version}\n`;
          if (signing.alias) notes += `- Signing Alias: ${signing.alias}\n`;
          notes += `\n## Artifacts Summary\n`;
          for (const [lbl, arr] of Object.entries(byLabel)) {
            notes += `\n### ${lbl} (${arr.length})\n`;
            for (const it of arr) notes += `- ${it.file} [${it.ext}] (size: ${it.size})\n`;
          }
          notes += `\nChecksums: Each artifact includes .sha256/.sha1/.md5 files.\n`;
          notes += `\n## Changes Since ${prev || 'initial'}\n${log}\n`;
          fs.writeFileSync('dist/meta/release-notes.md', notes);
          EOF

      - name: Validate meta JSON (SBOM & Manifest) with AJV
        shell: bash
        run: |
          set -e
          npx --yes ajv-cli@5.0.0 validate -s .github/schemas/artifacts-manifest.schema.json -d dist/meta/artifacts-manifest.json
          npx --yes ajv-cli@5.0.0 validate -s .github/schemas/sbom-cyclonedx-simple.schema.json -d dist/meta/sbom-npm.json

      - name: Validate SBOM with CycloneDX CLI (strict)
        continue-on-error: true
        shell: bash
        run: |
          set -e
          curl -sL https://github.com/CycloneDX/cyclonedx-cli/releases/latest/download/cyclonedx-linux-x64 -o cyclonedx
          chmod +x cyclonedx
          ./cyclonedx validate --input-file dist/meta/sbom-npm.json --input-format json --fail-on-errors || {
            echo "CycloneDX strict validation failed; recording warning and continuing.";
          }

      - name: Copy JSON Schemas into meta artifact
        shell: bash
        run: |
          set -e
          mkdir -p dist/meta/schema
          cp .github/schemas/*.json dist/meta/schema/

      - name: Upload SBOM/Manifest/Signing/Notes
        uses: actions/upload-artifact@v4
        with:
          name: meta-sbom-and-manifest
          path: dist/meta/**
          retention-days: 30
      - name: Upload Debug APK
        uses: actions/upload-artifact@v4
        with:
          name: android-apk-debug
          path: android/app/build/outputs/apk/debug/app-debug.apk
          if-no-files-found: warn
          retention-days: 30

      - name: Upload Tagged Release APKs
        if: ${{ env.ANDROID_KEYSTORE_BASE64 != '' }}
        uses: actions/upload-artifact@v4
        with:
          name: android-apk-release-tagged
          path: |
            android/app/build/outputs/apk/release/mood-flow-*-release-*.apk
            android/app/build/outputs/apk/release/mood-flow-*-signed-*.apk
            android/app/build/outputs/apk/release/mood-flow-*-sinternal-*.apk
            android/app/build/outputs/apk/release/mood-flow-*-store-*.apk
            # Fallback to generic outputs when tagging did not produce labeled files
            android/app/build/outputs/apk/release/app-release.apk
            android/app/build/outputs/apk/release/mood-flow-*.apk.sha256
            android/app/build/outputs/apk/release/mood-flow-*.apk.sha1
            android/app/build/outputs/apk/release/mood-flow-*.apk.md5
          if-no-files-found: warn
          retention-days: 30

      - name: Upload Tagged Release AABs (all labels)
        if: ${{ env.ANDROID_KEYSTORE_BASE64 != '' }}
        uses: actions/upload-artifact@v4
        with:
          name: android-aab-release-tagged
          path: |
            android/app/build/outputs/bundle/release/mood-flow-*-release-*.aab
            android/app/build/outputs/bundle/release/mood-flow-*-signed-*.aab
            android/app/build/outputs/bundle/release/mood-flow-*-sinternal-*.aab
            android/app/build/outputs/bundle/release/mood-flow-*-store-*.aab
            # Fallback to generic outputs when tagging did not produce labeled files
            android/app/build/outputs/bundle/release/app-release.aab
            android/app/build/outputs/bundle/release/mood-flow-*.aab.sha256
            android/app/build/outputs/bundle/release/mood-flow-*.aab.sha1
            android/app/build/outputs/bundle/release/mood-flow-*.aab.md5
          if-no-files-found: warn
          retention-days: 30

      - name: Upload Store AAB (for app store submission)
        if: ${{ env.ANDROID_KEYSTORE_BASE64 != '' }}
        uses: actions/upload-artifact@v4
        with:
          name: android-aab-store-only
          path: |
            android/app/build/outputs/bundle/release/mood-flow-*-store-*.aab
            android/app/build/outputs/bundle/release/mood-flow-*-store-*.aab.sha256
            android/app/build/outputs/bundle/release/mood-flow-*-store-*.aab.sha1
            android/app/build/outputs/bundle/release/mood-flow-*-store-*.aab.md5
          if-no-files-found: warn
          retention-days: 30

  publish-release:
    if: startsWith(github.ref, 'refs/tags/')
    needs: build-android
    runs-on: ubuntu-latest
    env:
      R2_BUCKET: ${{ secrets.R2_BUCKET }}
      R2_PUBLIC_BASE: ${{ secrets.R2_PUBLIC_BASE }}
    outputs:
      r2_apk_url: ${{ steps.append_r2_marker.outputs.r2_apk_url }}
    steps:
      - name: Download APK artifacts
        uses: actions/download-artifact@v4
        with:
          name: android-apk-release-tagged
          path: dist/apk
      - name: Download AAB artifacts (all labels)
        uses: actions/download-artifact@v4
        with:
          name: android-aab-release-tagged
          path: dist/aab
      - name: Download Store AAB (single)
        uses: actions/download-artifact@v4
        with:
          name: android-aab-store-only
          path: dist/aab-store
      - name: Download Meta artifacts
        uses: actions/download-artifact@v4
        with:
          name: meta-sbom-and-manifest
          path: dist/meta
      - name: Append R2 APK URL marker to release notes (pre-publish)
        id: append_r2_marker
        shell: bash
        run: |
          set -e
          APK_FILE=$(ls -1 dist/apk/mood-flow-*-store-*.apk | tail -n1 || true)
          if [ -z "$APK_FILE" ]; then
            APK_FILE=$(ls -1 dist/apk/mood-flow-*-release-*.apk | tail -n1 || true)
          fi
          if [ -z "$APK_FILE" ]; then
            echo "No APK file found to append marker" >&2
            exit 0
          fi
          BASENAME=$(basename "$APK_FILE")
          if [ -n "${R2_PUBLIC_BASE}" ]; then
            R2_URL="${R2_PUBLIC_BASE}/releases/${BASENAME}"
          elif [ -n "${R2_BUCKET}" ]; then
            R2_URL="https://${R2_BUCKET}.r2.dev/releases/${BASENAME}"
          else
            R2_URL=""
          fi
          BODY="dist/meta/release-notes.md"
          if [ -f "$BODY" ] && [ -n "$R2_URL" ]; then
            echo "R2_APK_URL: ${R2_URL}" >> "$BODY"
            echo "::notice title=R2 APK URL::${R2_URL}"
            # Expose as job output for downstream consumers/monitors
            echo "r2_apk_url=${R2_URL}" >> "$GITHUB_OUTPUT"
            # Also emit a distinct notice marker for log-based output parsing
            echo "::notice title=R2 APK URL OUTPUT::${R2_URL}"
            echo "Appended R2_APK_URL marker to release notes (publish-release)"
          else
            echo "Release notes missing or R2_URL empty; skip append" >&2
          fi
      - name: Publish GitHub Release with assets
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ github.ref_name }}
          body_path: dist/meta/release-notes.md
          # Avoid duplicate uploads: store-labeled AABs are already included in dist/aab/**
          # Allow unmatched globs to be skipped without failing the job
          fail_on_unmatched_files: false
          files: |
            dist/apk/**
            dist/aab/**
            dist/meta/**
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      - name: Print R2 APK URL (notice)
        shell: bash
        run: |
          set -e
          APK_FILE=$(ls -1 dist/apk/mood-flow-*-store-*.apk | tail -n1 || true)
          if [ -z "$APK_FILE" ]; then
            APK_FILE=$(ls -1 dist/apk/mood-flow-*-release-*.apk | tail -n1 || true)
          fi
          if [ -n "$APK_FILE" ]; then
            BASENAME=$(basename "$APK_FILE")
            if [ -n "${R2_PUBLIC_BASE}" ]; then
              URL="${R2_PUBLIC_BASE}/releases/${BASENAME}"
            else
              URL="https://${R2_BUCKET}.r2.dev/releases/${BASENAME}"
            fi
            echo "::notice title=R2 APK URL::${URL}"
          else
            echo "No APK found to construct R2 URL" >&2
          fi
